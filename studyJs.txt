
-------------------------------------------x-----------------------------x-----------------------------
Everything in javascript happens inside an execution context

assume javascript as a big box or a container in which whole code is executed that container is divided into two parts and those two parts are:-

memory container and code container 

memory container:- here everything is stored in key value pair relationship for example var a=10;
a is the key and 10 is the value even functions are stored in key value pair relationship
this memory container is also known as variable environment, It is sort of an environment in which everything is stored as a key value pair relationship


code component:-
here the code is executed one line at a time
this is also called as thread of execution



----------------------------------------------------x-------------------------x------------------

Javascript is a synchronous single threaded language

here single threaded means that it will execute the code one command at a time and in a specific order

synchronous single thread means:-
i.e. it will only go below once the current line is executed


what happens when we run a js code:-

---------------------------------------
let n =2;                             |
                                      |
let squareNum =(n)=>{  (here n is the argument)               
int ans  = n*n;                       |
return n;                             |
}                                     | 
                                      |
let square = squareNum(n); (here n is the parameter of the function)
                                      |
let square4 = squareNum(4);           |
                                      |
---------------------------------------

when you run the code above a global execution context is created:-
the execution context is created in two phases that is 
the memory creation phase and
the code execution phase
two components are created memory and code component.

Now in the first memory phase :-
as it encounter line 1 it will allocate memory n 
in line 2 it will allocate memory to squareNum

now in n it will store a value which is undefined

and in function squareNum it will store the whole code in variable named squareNum

then in below line it will allocate memory to square and square4 which is undefined



the second phase is the code execution phase:-
so now the js will go line by line again and as soon as it ecounters line 1 it will place the value to the variable that is n = 2

in the next line it has nothing to execute as the function is already stored in memory phase so it goes to next line where a variable is invoking a function in line 
square =  squareNum(n);

function is like a mini program and now inside a function a new execution context is created inside a global execution context and inside the mini execution context
memory creation and code execution phase happens where we allocate memory and initialize variable and do the code that it is written in inside the function and return the variable 

what happens while executing return statement:-
whenever we see a return then we inform the function that our work here is done and return the control of the program where it was invoked

now hwen the execution context for line:-
let square = squareNum(n); is done then that whole execution context is deleted.

now in the next line another mini execution context is created and does the same thing as the previous mini execution context has done.

hwne each line is executed or the program is finished then the whole global execution context is deleted


-----------------------------------------x------------------------x----------------------------------------
if we use function as an arrow function then it will behave as a variable so in that case we cannot initialize a function name first and then make the function which is possible while making normal js function.

------------------------------------------------------------------------------
HOISTING of LET and CONST 

let a =10;
var b=20;

-----------------x-------------------x-----------------------
console.log(b);
let a=10;
var b =100;


now in js here you would get an undefined when we try to print b before it's initialization due to hoisting
------------------------x---------------------x---------------------------------
console.log(a);
let a=10;
var b =100;


here you will get an error which:- says namasteJs1.js:10 Uncaught ReferenceError: Cannot access 'a' before initialization


memory was assigned to be through var declaration and b was attached to the global object but in case of let and const they are allocated memory but they are stored in a separate memory space than global space and you cannot access that memory space before you have put in some value in there
---------------------x--------------------------------x-----------------

temporal dead zone is the time since when this let variable was hoisted and and till it is initialized some value is called as temporal dead zone

---------------------------------------------------------------------------------

difference between syntax ,type and reference error:-

type error occurs during initialization for example:-

const b ;
b==100;
console.log(b);

here type error will occur:-uncaught type error : assignment to constant variable.

Syntax ERROR:-
syntax error occurs when there is a problem in syntax for example:-

const b;

here you will get a syntax error:- missing initializer in const declaration.

Reference error:-
for ex:-
console,log(a);
let a=9;
here you will get a reference error:-
cannot access 'a' before initialization.
-----------------------------------------------------------------------------------------
difference between var,let and const?

const is for permanent declaration which will not change for example 
name,birth year etc

let:- it has a temporal deadzone which avoids error like undefined etc

var is not used often in today's js as it is old age.

to avoid temporal deadzone just put deckaration on top of the scope which will help us avoid unexpected error to avoid temporal dead zone.
----------------------x-------------------------x-------------------------x----------------

Block scope and shadowing:-

what is block?
block is also known as compound statement it is used to combine multiple js line into a single group
we group multiple statements together in a block so that we can use it where js expects one statements.
for example :-

if(true){
var a = 10;
console.log(a);
}

code inside {} is called a block where js expects only one statement

here that one statement is "10"
--------------------------------------------------------------------------------------
what is block scoped?
whatever variable, function is accessible inside that block is called block scope

for ex:-
{
var a=10;
let b=20;
const c =30;
}

here when we check var a will be globally scoped an let, const will be blocked scoped
as it is stored in a reserved memory space which is for the block

{
var a=10;
let b=20;
const c =30;
console.log(a);
console.log(b);
console.log(a);

}
console.log(a);
console.log(b);
console.log(c);


here you will get output as 
10
20
30
10

first 10,20,30 are from the {} and then another 10 is print because a is global scoped 
for 
console.log(b);
console.log(c);
it will show a reference error as b and c are not in global scope.
----------------------------------------------------------------------------------
what is shadowing?

if we have same name variable outside the scope for example:-
var a=100;
{
var a=10;
let b=20;
const c =30;
console.log(a);
console.log(b);
console.log(a);

}
so in this case the variable a in block will shadow the variable a outside the scope and it will print 10.

now in another case:-
var a=100;
{
var a=10;
let b=20;
const c =30;
console.log(a);
console.log(b);
console.log(a);

}
console.log(a);

now the print statement outside it will print 10 as it is shadowing the var a =100 because both of them are pointing at one var a in global scope and since a=10 line is below it is overriding that value and updating it to 10 so this is called shadowing.

the above case will only occur when it is var incase of let and const ot will not happen since let and const both are block scoped and var is global scoped
let b=100;
{
var a=10;
let b=20;
const c =30;
console.log(a);
console.log(b);
console.log(a);

}
console.log(b);

here you will get output as 
10
20
30
100

since the first three are printed as they were in block and shadowing only occurs for let and const when they are inside the block out side the block let b =20 is shadowed and in the first line b=100 is printed as it is within another memory space called script where let and const variables are stored another space other than global scope



